{"version":3,"file":"static/js/pc-finder.worker.375fb0c7.worker.js","mappings":"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","sources":["constants/minodata.ts","scripts/util.ts","scripts/pc-finder.worker.ts"],"sourcesContent":["export const minoTypes = {\n    \"I\": [[-1, 0], [ 0, 0], [ 1, 0], [ 2, 0]],\n\n    \"O\": [         [ 0, 1], [ 1, 1], \n                   [ 0, 0], [ 1, 0]],\n\n    \"T\": [         [ 0, 1], \n          [-1, 0], [ 0, 0], [ 1, 0]],\n\n    \"L\": [                  [ 1, 1], \n          [-1, 0], [ 0, 0], [ 1, 0]],\n\n    \"J\": [[-1, 1], \n          [-1, 0], [ 0, 0], [ 1, 0]],\n\n    \"Z\": [[-1, 1], [ 0, 1], \n                   [ 0, 0], [ 1, 0]],\n\n    \"S\": [         [ 0, 1], [ 1, 1], \n          [-1, 0], [ 0, 0]],\n};\n\n\n// SRS\nexport const srsOffsets = {\n    I: [\n        [[ 0, 0], [-1, 0], [+2, 0], [-1, 0], [+2, 0]],\n        [[-1, 0], [ 0, 0], [ 0, 0], [ 0,+1], [ 0,-2]],\n        [[-1, +1], [+1,+1], [-2,+1], [+1, 0], [-2, 0]],\n        [[ 0,+1], [ 0,+1], [ 0,+1], [ 0,-1], [ 0,+2]]\n    ],\n    O: [\n        [[ 0, 0]],\n        [[ 0,-1]],\n        [[-1,-1]],\n        [[-1, 0]]\n    ],\n    T: [\n        [[ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0]],\n        [[ 0, 0], [+1, 0], [+1,-1], [ 0,+2], [+1,+2]],\n        [[ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0]],\n        [[ 0, 0], [-1, 0], [-1,-1], [ 0,+2], [-1,+2]]\n    ],\n    L: [\n        [[ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0]],\n        [[ 0, 0], [+1, 0], [+1,-1], [ 0,+2], [+1,+2]],\n        [[ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0]],\n        [[ 0, 0], [-1, 0], [-1,-1], [ 0,+2], [-1,+2]]\n    ],\n    J: [\n        [[ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0]],\n        [[ 0, 0], [+1, 0], [+1,-1], [ 0,+2], [+1,+2]],\n        [[ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0]],\n        [[ 0, 0], [-1, 0], [-1,-1], [ 0,+2], [-1,+2]]\n    ],\n    Z: [\n        [[ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0]],\n        [[ 0, 0], [+1, 0], [+1,-1], [ 0,+2], [+1,+2]],\n        [[ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0]],\n        [[ 0, 0], [-1, 0], [-1,-1], [ 0,+2], [-1,+2]]\n    ],\n    S: [\n        [[ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0]],\n        [[ 0, 0], [+1, 0], [+1,-1], [ 0,+2], [+1,+2]],\n        [[ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0], [ 0, 0]],\n        [[ 0, 0], [-1, 0], [-1,-1], [ 0,+2], [-1,+2]]\n    ],\n};\n\n// used for blocksheet:\n// enum minoIndexes {\n//     'I',\n//     'O',\n//     'T',\n//     'L',\n//     'J',\n//     'Z',\n//     'S',\n//     'G'\n// };\nexport const minoIndexes = {\n    'I': 0,\n    'O': 1,\n    'T': 2,\n    'L': 3,\n    'J': 4,\n    'Z': 5,\n    'S': 6,\n    'G': 7\n};\n\nexport const blocksize = 32;\n","import { minoTypes, minoIndexes, blocksize } from \"../constants/minodata\";\n\nimport { Mino, minoType, Blocks } from \"../types/types\";\n\nexport const collide = (b: Blocks, m: Mino): boolean => {\n\n    for (let block of m.blocks) {\n        if (b[block[1]]?.[block[0]] === undefined || b[block[1]][block[0]]) {\n            return true;\n        }\n    }\n    return false;\n}\n\nexport const getNewMino = (type: minoType, ox = 0, oy = 0): Mino => {\n    let blocks = minoTypes[type].map(block => [ox + block[0], oy + block[1]] as [number, number]);\n\n    return {\n        blocks: blocks,\n        type: type,\n        perm: 0,\n        ox: ox,\n        oy: oy\n    }\n}\n\nexport const getMovedMino = (m: Mino, x: number, y: number) : Mino => {\n    const newBlocks = m.blocks.map(block => [block[0] + x, block[1] + y] as [number, number])\n    return {\n        ...m,\n        blocks: newBlocks,\n        ox: m.ox + x,\n        oy: m.oy + y\n    }\n}\n\nexport const getRotatedMino = (m: Mino, n: number) : Mino => {\n    const numRotations = ((n % 4) + 4) % 4\n    let newBlocks = m.blocks;\n\n    for (let i = 0; i < numRotations; i++){\n        newBlocks = newBlocks.map((block => [(block[1] - m.oy) + m.ox, -(block[0] - m.ox) + m.oy] as [number, number]))\n    }\n\n    return {\n        ...m,\n        blocks: newBlocks,\n        perm: (m.perm + numRotations) % 4\n    }\n}\n\nexport const lowest = (b: Blocks, m: Mino): Mino => {\n    let i = -1\n    let tempMino = getMovedMino(m, 0, i);\n\n    while (!collide(b, tempMino)){\n        i--;\n        tempMino = getMovedMino(m, 0, i);\n    }\n\n    return getMovedMino(m, 0, i + 1);\n}\n\nexport const drawMino = (ctx: CanvasRenderingContext2D, m: Mino) => {\n    const blocksheetSprite = new Image();\n    blocksheetSprite.src = require(\"../img/blocksheet.png\");\n\n    const heightOffset = ctx.canvas.height / blocksize - 1; \n\n    for (let block of m.blocks) {\n        ctx.drawImage(\n            blocksheetSprite,\n            blocksize * minoIndexes[m.type as keyof typeof minoIndexes],\n            0,\n            blocksize,\n            blocksize, \n            block[0] * blocksize,\n            (heightOffset - block[1]) * blocksize,\n            blocksize,\n            blocksize\n        );\n    }\n}\n\nexport const getShuffledQueue = (): minoType[] => {\n    //Fisher-Yates shuffle\n    let base = ['T', 'I', 'O', 'L', 'J', 'S', 'Z'] as minoType[];\n    let remaining = base.length;\n    \n    let i;\n    while (remaining){\n        i = Math.floor(Math.random() * remaining--);\n        [base[remaining], base[i]] = [base[i], base[remaining]];\n    }\n\n    return base;\n}\n\n// used for drawing in hold and queue:\nexport const getMinoWidth = (m: Mino): number => {\n    const seen: number[] = [];\n    m.blocks.forEach(block => {\n        if (!seen.includes(block[0])) {\n            seen.push(block[0]);\n        }\n    })\n    return seen.length;\n}\n\nexport const getMinoHeight = (m: Mino): number => {\n    const seen: number[] = [];\n    m.blocks.forEach(block => {\n        if (!seen.includes(block[1])) {\n            seen.push(block[1]);\n        }\n    })\n    return seen.length;\n}\n\nexport const getBoardWithPlacedMinos = (b: Blocks, minos: Mino[]): Blocks => {\n    \n    const new_b: Blocks = Array.from({ length: 4 }, () => Array(10).fill('')) // fills with blocks\n    // offset is to cover for if any lines are cleared in the middle of the solution\n    let offset = Array(4).fill(0);\n    const cleared = Array(4).fill(false)\n\n    for (let m of minos) {\n\n        for (let block of m.blocks) {\n            new_b[block[1] + offset[block[1]]][block[0]] = m.type;\n        }\n\n        // check if any lines have been cleared, if so, modify offset appropriately\n        let new_offset = offset.slice()\n\n        for (let row = 3; row >= 0; row--) {\n            if (!cleared[row]) {\n                let sum = 0;\n                for (let block = 0; block < 10; block++) {\n                    if (b[row][block] !== '' || new_b[row][block] !== '') {\n                        sum++;\n                    }\n                }\n\n                if (sum === 10) {\n                    // modifying offset\n                    new_offset.splice(row - offset[row], 1)\n                    for (let i = row - offset[row]; i < new_offset.length; i++) {\n                        new_offset[i]++;\n                    }\n                    new_offset.push(new_offset[new_offset.length - 1])\n                    cleared[row] = true\n                }\n            }\n        }\n\n        offset = new_offset.slice()\n    }\n\n    return new_b;\n}","// // eslint-disable-next-line no-restricted-globals\n// const ctx: Worker = self as any;\n\n// // Respond to message from parent thread\n// ctx.addEventListener(\"message\", (event) => console.log(event));\n\nimport { minoTypes, srsOffsets } from '../constants/minodata'\nimport { getBoardWithPlacedMinos } from './util';\n\ntype minoType = 'I' | 'O' | 'T' | 'L' | 'J' | 'Z' | 'S';\n\ninterface Mino {\n    blocks: [number, number][],\n    type: minoType;\n    perm: number;\n    ox: number,\n    oy: number,\n}\n\ntype blockType = minoType | 'G' | ''\n\ntype Blocks = blockType[][]\n\nconst getNewMino = (type: minoType, ox = 0, oy = 0): Mino => {\n    let blocks = minoTypes[type].map(block => [ox + block[0], oy + block[1]] as [number, number]);\n\n    return {\n        blocks: blocks,\n        type: type,\n        perm: 0,\n        ox: ox,\n        oy: oy\n    }\n}\n\nconst getMovedMino = (m: Mino, x: number, y: number) : Mino => {\n    const newBlocks = m.blocks.map(block => [block[0] + x, block[1] + y] as [number, number])\n    return {\n        ...m,\n        blocks: newBlocks,\n        ox: m.ox + x,\n        oy: m.oy + y\n    }\n}\n\nconst getRotatedMino = (m: Mino, n: number) : Mino => {\n    const numRotations = ((n % 4) + 4) % 4\n    let newBlocks = m.blocks;\n\n    for (let i = 0; i < numRotations; i++){\n        newBlocks = newBlocks.map((block => [(block[1] - m.oy) + m.ox, -(block[0] - m.ox) + m.oy] as [number, number]))\n    }\n\n    return {\n        ...m,\n        blocks: newBlocks,\n        perm: (m.perm + numRotations) % 4\n    }\n}\n\nconst collide = (b: Blocks, m: Mino): boolean => {\n    for (let block of m.blocks) {\n        if (b[block[1]]?.[block[0]] === undefined || b[block[1]][block[0]]) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction topless_collide(b: Blocks, m: Mino): boolean{ // collide that doesn't trigger on top undefined\n    for (let block of m.blocks) {\n        if (block[1] >= b.length && (0 <= block[0] && block[0] < 10)) {}\n        else if (b[block[1]]?.[block[0]] === undefined || b[block[1]][block[0]]) {\n            return true;\n        }\n    }\n    return false\n}\n\nconst setMultipleBlocks = (b: Blocks, blocklist: [number, number][], type: blockType) => {\n    let tempBlocks = JSON.parse(JSON.stringify(b)) as Blocks;\n    \n    for (let block of blocklist) {\n        if (block[0] < 10 && block[1] < 4) {\n            tempBlocks[block[1]][block[0]] = type;\n        }\n    }\n\n    // check to clear lines:\n    for (let i = 0; i < tempBlocks.length; i++){\n        if (!tempBlocks[i].includes('')) {\n            tempBlocks.splice(i, 1);\n            // tempBlocks.push(Array(10).fill(''));\n            i--;\n        }\n    }\n\n    return tempBlocks;\n}\n\n// when it gets input from the main file, run everything else.\n// state.data has b (2d Array of Chars), curr (Char), hold (Char), queue (Array of Chars)\nonmessage = (msg: MessageEvent) => {\n    console.log('message received');\n    const state: {b: Blocks, hold: minoType, queue: minoType[]} = msg.data;\n\n    // if hold exists, append current mino to beginning of queue, otherwise make current mino held\n    let new_queue = [...state.queue];\n    let new_hold: minoType | undefined;\n\n    if (state.hold != null) {\n        new_hold = state.hold; \n    }\n    else {\n        new_hold = new_queue.shift();\n    }\n\n    const stackHeight = state.b.reduce((acc, row, i) => {\n        if (row.some(block => block !== '')) {\n            return i + 1;\n        } else {\n            return acc;\n        }\n    }, 0);\n    \n    const new_b = JSON.parse(JSON.stringify(state.b)).slice(0, Math.max(stackHeight, 4)); \n\n    let solutions: Mino[][];\n    if (!new_hold || stackHeight === 0) {\n        solutions = [];\n    } else {\n        solutions = getAllPCs(new_b, new_queue, new_hold);\n    }\n\n    solutions = eliminate_duplicate_solutions(new_b, solutions);\n\n    postMessage(solutions);\n\n    console.log('finished.')\n}\n\nfunction getAllPCs(b: Blocks, queue: minoType[], hold: minoType): Mino[][] {\n    let result = [] as Mino[][];\n\n    for (let h = 1; h < 5; h++){\n        if (is_pcable(b, queue, h)){\n            // console.log(`searching for ${h}-height pcs...`)\n            result = [...result, ...getAllPCsByHeight(b, queue, hold, h)]; \n        }\n    }\n    \n    return result;\n}\n\nfunction is_pcable(b: Blocks, queue: minoType[], height=4): boolean{// check if board is pc-able given queue\n    // check if board height is higher than pc height\n    for (let i = height; i < b.length; i++){        \n        for (let block of b[i]){\n            if (block) {\n                // console.log(`Board height is higher than ${height}!`)\n                return false;\n            }\n        }\n    }\n    \n    // check if number of empty spaces on board is divisible by 4\n    let empty_blocks = 0;\n    for (let row of b){        \n        empty_blocks += row.reduce((acc, block) => acc += (block === '' ? 1 : 0), 0);\n    }\n    if (empty_blocks % 4 !== 0) {\n        // console.log('Remaining space is not divisible by 4!')\n        return false;\n    }\n\n    // check if queue length is long enough to pc\n    if (empty_blocks / 4 > queue.length) {\n        // console.log('Queue is not long enough!')\n        return false;\n    }\n\n    return true;\n}\n\nfunction is_lowest(b: Blocks, m: Mino){\n    for (let block of m.blocks){\n        if (block[1] === 0){\n            return true;\n        } \n        else if (b[block[1] - 1][block[0]]){\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction get_all_lowest(b: Blocks, type: minoType, height=4): Mino[] {\n    let result = [];\n\n    for (let perm = 0; perm < 4; perm++){\n        for (let x = 0; x < 10; x++){\n            for (let y = 0; y < height; y++){\n                const tempmino = getRotatedMino(getNewMino(type, x, y), perm);\n                if (!collide(b, tempmino) && is_lowest(b, tempmino) && is_reachable(b, tempmino, 0)){\n                    result.push(tempmino);\n                }\n            }\n        }\n        if (type === 'O' && perm > 0) break;\n    }\n\n    return result;\n}\n\nfunction is_reachable(b: Blocks, m: Mino, iter=0): boolean {\n    // check if we've already done too much iterations of this, currently set to maximum 3 but can add more\n    if (iter > 4){\n        return false;\n    }\n\n    // check if the mino is already collided with the board\n    // this is collide() from main file, modified so blocks above board don't trigger collision\n    if (topless_collide(b, m)){\n        return false;\n    }\n\n    // check if it can just go straight up\n    let can_go_up = true;\n    for (let block of m.blocks){\n        if (can_go_up){\n            for (let i = 0; i < b.length; i++){\n                if (b[block[1] + i]?.[block[0]]){\n                    can_go_up = false;\n                    break;\n                }\n            }\n        }\n        else break;\n    }\n    if (can_go_up) return true;\n\n    // check each dir: up, left, right (no down)\n    if (is_reachable(b, getMovedMino(m, 0, 1), iter + 1) ||\n        is_reachable(b, getMovedMino(m, -1, 0), iter + 1) ||\n        is_reachable(b, getMovedMino(m, 1, 0), iter + 1)) {\n        return true;\n    }\n    // check each rotation, don't check if O piece\n    else if (m.type !== 'O'){\n        for (let rot = 1; rot < 4; rot++) {\n            // check each offset:\n            for (let os = 0; os < 5; os++) {\n                // setting up the offset values\n                let oldperm = (m.perm + rot + 4) % 4\n                let offset = [\n                    srsOffsets[m.type][oldperm][os][0] - srsOffsets[m.type][m.perm][os][0],\n                    srsOffsets[m.type][oldperm][os][1] - srsOffsets[m.type][m.perm][os][1]\n                ] as [number, number];\n                \n                // create copy of m, rotate it, and apply reversed offset\n                const possibleOldMino = getRotatedMino(getMovedMino(m, -offset[0], -offset[1]), rot); \n                \n                if (!topless_collide(b, possibleOldMino)) {\n                    // rotate the possible old mino to check if the spin is actually what happens\n                    const currOffset = srsOffsets[possibleOldMino.type];\n                    const rotatedOldMino = getRotatedMino(possibleOldMino, -rot + 4); // -rot + 4 undoes rotation\n\n                    for (let i = 0; i < currOffset[possibleOldMino.perm].length; i++) {\n                        const offset = [\n                            currOffset[possibleOldMino.perm][i][0] - currOffset[rotatedOldMino.perm][i][0],\n                            currOffset[possibleOldMino.perm][i][1] - currOffset[rotatedOldMino.perm][i][1]\n                        ]\n                        const offsetMino = getMovedMino(rotatedOldMino, offset[0], offset[1])\n\n                        // check if the rotated old mino becomes the mino we want\n                        if (!topless_collide(b, offsetMino)) {\n                            if (offsetMino.ox === m.ox && offsetMino.oy === m.oy &&\n                                is_reachable(b, possibleOldMino, iter + 1)) {\n                                return true;\n                            } else {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return false;\n}\n\nfunction getAllPCsByHeight(b: Blocks, queue: minoType[], hold: minoType, height: number = 4): Mino[][] {\n\n    interface State {\n        blocks: Blocks,\n        queue: minoType[],\n        hold: minoType,\n        history: Mino[],\n    }\n\n    const searchQueue: State[] = [{\n        blocks: b,\n        queue: queue,\n        hold: hold,\n        history: []\n    }];\n    const result: Mino[][] = [];\n\n    while (searchQueue.length > 0) {\n        const currState = searchQueue.shift()!;\n        const new_b = currState.history.length > 0 ? \n        setMultipleBlocks(\n            currState.blocks, \n            currState.history[currState.history.length - 1].blocks, \n            currState.history[currState.history.length - 1].type\n        ) :\n        JSON.parse(JSON.stringify(currState.blocks)) as Blocks;\n\n        if (new_b.length === 0) {\n            result.push(currState.history);\n\n            // if (result.length % 10 === 0) console.log(`found ${result.length} solutions...`);\n        } else {\n            if (currState.queue.length <= 0 && currState.hold === null) {\n                // pass\n            }\n            // else if (seen_boards.includes(JSON.stringify([queue[0], ...new_b.blocks]))){\n            //     // pass\n            // }\n            else {\n                // seen_boards.push(JSON.stringify([queue[0], ...new_b.blocks]))\n\n                // current mino as next\n                for (let m of get_all_lowest(new_b, currState.queue[0], currState.blocks.length)) {\n                    searchQueue.push({\n                        blocks: new_b,\n                        queue: currState.queue.slice(1),\n                        hold: currState.hold,\n                        history: [...currState.history, m]\n                    })\n                }\n\n                // hold mino as next\n                for (let m of get_all_lowest(new_b, currState.hold, currState.blocks.length)) {\n                    searchQueue.push({\n                        blocks: new_b,\n                        queue: currState.queue.slice(1),\n                        hold: currState.queue[0],\n                        history: [...currState.history, m]\n                    })\n\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\nfunction eliminate_duplicate_solutions(b: Blocks, sols: Mino[][]): Mino[][] {\n    let new_sols = []; \n    let seen = []; \n\n    for (let s of sols){\n\n        let new_b = getBoardWithPlacedMinos(b, s);\n\n        let was_seen = false; \n        for (let arrangement of seen){\n            if (JSON.stringify(new_b) === JSON.stringify(arrangement)) {\n                was_seen = true;\n                break;\n            }\n        }\n\n        if (!was_seen){\n            seen.push(new_b);\n            new_sols.push(s);\n        }\n    }\n\n    return new_sols;\n}\n\nexport {}"],"names":["minoTypes","srsOffsets","I","O","T","L","J","Z","S","getBoardWithPlacedMinos","b","minos","new_b","Array","from","length","fill","offset","cleared","m","block","blocks","type","new_offset","slice","row","sum","splice","i","push","getNewMino","ox","arguments","undefined","oy","map","perm","getMovedMino","x","y","newBlocks","getRotatedMino","n","numRotations","collide","_b$block$","topless_collide","_b$block$2","setMultipleBlocks","blocklist","tempBlocks","JSON","parse","stringify","includes","is_pcable","queue","empty_blocks","reduce","acc","is_lowest","get_all_lowest","height","result","tempmino","is_reachable","iter","can_go_up","_b","rot","os","oldperm","possibleOldMino","currOffset","rotatedOldMino","offsetMino","getAllPCsByHeight","hold","searchQueue","history","currState","shift","onmessage","msg","console","log","state","data","new_hold","new_queue","stackHeight","some","Math","max","solutions","h","getAllPCs","sols","new_sols","seen","s","was_seen","arrangement","eliminate_duplicate_solutions","postMessage"],"sourceRoot":""}